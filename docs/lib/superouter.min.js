!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).superouter=e()}}(function(){return function(){return function e(t,a,r){function n(s,o){if(!a[s]){if(!t[s]){var c="function"==typeof require&&require;if(!o&&c)return c(s,!0);if(i)return i(s,!0);var l=new Error("Cannot find module '"+s+"'");throw l.code="MODULE_NOT_FOUND",l}var u=a[s]={exports:{}};t[s][0].call(u.exports,function(e){return n(t[s][1][e]||e)},u,u.exports,e,t,a,r)}return a[s].exports}for(var i="function"==typeof require&&require,s=0;s<r.length;s++)n(r[s]);return n}}()({1:[function(e,t,a){const r={name:"Valid",Y:e=>({case:"Y",type:"Valid",value:e}),N:e=>({case:"N",type:"Valid",value:e}),bifold:(e,t)=>a=>({Y:t,N:e})[a.case](a.value),fold:({Y:e,N:t})=>a=>({Y:e,N:t})[a.case](a.value),map:e=>t=>({Y:t=>r.Y(e(t)),N:()=>t})[t.case](t.value)},n={name:"PatternToken",Path:e=>({case:"Path",value:e,type:"PatternToken"}),Part:e=>({case:"Part",value:e,type:"PatternToken"}),Variadic:e=>({case:"Variadic",value:e,type:"PatternToken"}),specificity:e=>n.fold({Path:()=>256,Part:()=>16,Variadic:()=>1})(e),groupSpecificity:e=>e.map(n.specificity).reduce((e,t)=>e+t,0),fold:({Path:e,Part:t,Variadic:a})=>r=>({Path:e,Part:t,Variadic:a})[r.case](r.value),infer:e=>e.startsWith(":")?n.Part(e.slice(1)):e.startsWith("...")?n.Variadic(e.split("...")[1]):n.Path(e),groupValidations:{duplicateDef:e=>{const t=e.map(([e,t])=>[e,n.toPattern(t)]).reduce((e,[t,a])=>(e[a]=e[a]||[],e[a].push(t),e),{}),a=Object.entries(t).reduce((e,[t,a])=>(a.length>1&&a.forEach(r=>{e[r]={caseNames:a,patternStr:t}}),e),{});return Object.keys(a).length?r.N(Object.entries(a).map(([e,{caseNames:t,patternStr:a}])=>[e,n.Error.DuplicateDef({caseNames:t,patternStr:a})])):r.Y(e)}},singleValidations:{variadicPosition:e=>{const t=e.findIndex(n.isVariadic);return t>-1&&t!=e.length-1?r.N(n.Error.VariadicPosition({tokens:e,index:t})):r.Y(e)},variadicCount:e=>{const t=e.filter(n.isVariadic);return t.length>1?r.N(n.Error.VariadicCount({variadics:t,tokens:e})):r.Y(e)},duplicatePart:e=>{const t=[e.flatMap(n.fold({Path:()=>[],Part:e=>[e],Variadic:e=>[e]})).reduce((e,t)=>(e[t]=e[t]||0,e[t]=e[t]+1,e),{})].flatMap(e=>Object.entries(e).flatMap(([e,t])=>t>1?[e]:[]));return t.length?r.N(n.Error.DuplicatePart({dupeParts:t})):r.Y(e)}},Error:{name:"PatternToken.Error",VariadicPosition:({tokens:e,index:t})=>({type:"PatternToken.Error",case:"VariadicPosition",value:new TypeError("Variadic "+JSON.stringify(n.toString(e[t]))+" found at position "+t+" of "+e.length+" of pattern "+JSON.stringify(n.toPattern(e))+".  Variadics can only be in the final position.")}),VariadicCount:({variadics:e,tokens:t})=>({type:"PatternToken.Error",case:"VariadicCount",value:new TypeError("Found "+e.length+" variadics in pattern "+n.toPattern(t)+".  A maxiumum of 1 variadic is allowed.")}),DuplicateDef:({caseNames:e,patternStr:t})=>({type:"PatternToken.Error",case:"DuplicateDef",value:new TypeError("Found duplicate pattern defintions for routes: "+e.join(", ")+".  They all have equivalent pattern strings: "+t+".  Duplicated patterns lead to ambiguous matches.")}),DuplicatePart:({dupeParts:e})=>({type:"PatternToken.Error",case:"DuplicatePart",value:new TypeError("Found duplicate variable bindings: "+e.join(", ")+".  Duplicated names lead to ambiguous bindings.")})},isVariadic:e=>"Variadic"===e.case,validate(e){const t=Object.values(n.singleValidations).map(t=>t(e)).filter(e=>"N"===e.case).map(e=>e.value);return t.length>0?r.N(t):r.Y(e)},validateGroup(e){const t=e.filter(([,e])=>"Y"===e.case),a=Object.values(n.groupValidations).map(e=>e(t.map(([e,t])=>[e,t.value]))).filter(e=>"N"===e.case).map(e=>e.value);return a.length>0?r.N(a):r.Y(e)},toString:e=>({Path:e=>e,Part:e=>":"+e,Variadic:e=>"..."+e})[e.case](e.value),toPattern:e=>e.map(n.toString).join("/")},i={Path:e=>({case:"Path",value:e,type:"URLToken"}),Part:({key:e,value:t})=>({case:"Part",value:{key:e,value:t,type:"URLToken"}}),Variadic:({key:e,value:t})=>({case:"Variadic",value:{key:e,value:t,type:"URLToken"}}),Unmatched:({expected:e,actual:t})=>({case:"Unmatched",value:{expected:e,actual:t},type:"URLToken"}),ExcessSegment:e=>({case:"ExcessSegment",value:e,type:"URLToken"}),fold:({Path:e,Part:t,Variadic:a,Unmatched:r,ExcessSegment:n})=>i=>({Path:e,Part:t,Variadic:a,Unmatched:r,ExcessSegment:n})[i.case](i.value),toString:e=>i.fold({Path:e=>e,Part:({value:e})=>e,Variadic:({value:e})=>e,Unmatched:({actual:e})=>e,ExcessSegment:e=>e})(e),toURL:e=>e.map(i.toString).join("/"),toArgs:e=>e.reduce((e,t)=>i.fold({ExcessSegment:()=>e,Part:({key:t,value:a})=>Object.assign(e,{[t]:a}),Path:()=>e,Unmatched:()=>e,Variadic:({key:t,value:a})=>Object.assign(e,{[t]:a})})(t),{}),fromPattern:e=>t=>n.fold({Path:e=>t===e?i.Path(t):i.Unmatched({expected:e,actual:t}),Part:e=>i.Part({key:e,value:t}),Variadic:e=>i.Variadic({key:e,value:t})})(e),isVariadic:e=>"Variadic"===e.case,validations:{excessPatterns:e=>t=>{const a=t.length,n=e.length>a?e.slice(a):[];return n.length?r.N(i.Error.ExcessPattern({urlTokens:t,patternTokens:e,excessPatterns:n})):r.Y(t)},excessSegments:e=>t=>{const a=t.filter(e=>"ExcessSegment"===e.case);return a.length&&"Variadic"!==e.slice(-1)[0].case?r.N(i.Error.ExcessSegment({patternTokens:e,extraSegments:a})):r.Y(t)},unmatchedPaths:e=>t=>{return t.filter(e=>"Unmatched"===e.case).length?r.N(i.Error.UnmatchedPaths({patternTokens:e,urlTokens:t})):r.Y(t)}},Error:{UnmatchedPaths:({patternTokens:e,urlTokens:t})=>({type:"URLToken.Error",case:"UnmatchedPaths",value:new TypeError("Pattern "+n.toPattern(e)+" could not match URL "+i.toURL(t)+" due to unmatched path segments: "+t.map(e=>"Unmatched"===e.case?i.toString(e):"...").join("/"))}),ExcessSegment:({patternTokens:e,extraSegments:t})=>({type:"URLToken.Error",case:"ExcessSegment",value:new TypeError("Excess tokens ("+JSON.stringify("/"+t.map(e=>e.value).join("/"))+") were found and the URLPattern:"+JSON.stringify(n.toPattern(e))+" did not contain a variadic for the additional values.")}),ExcessPattern:({urlTokens:e,excessPatterns:t,patternTokens:a})=>({type:"URLToken.Error",case:"ExcessPattern",value:new TypeError("The URL "+i.toURL(e)+" had excess patterns ("+n.toPattern(t)+")when parsed as part of pattern: "+n.toPattern(a))})},transforms:{collectVariadics:e=>t=>a=>{if((a.length>t.length?a.slice(t.length):[]).length){const r=a.findIndex(i.isVariadic);if(-1==r)return a;{const{key:n,value:s}=a[r].value;return a.slice(0,t.length-1).concat(i.Variadic({key:n,value:s+"/"+e.split("/").slice(t.length).join("/")}))}}return a}},transform:(e,t,a)=>Object.values(i.transforms).reduce((t,r)=>r(e)(a)(t),t),validate(e,t){const a=Object.values(i.validations).map(a=>a(e)(t)).filter(e=>"N"===e.case).map(e=>e.value);return a.length>0?r.N(a):r.Y(t)}};function s(e){return[e.split("/").map(n.infer)].map(n.validate).shift()}function o(e,t){const a=t.split("/").slice(0,e.length).map((t,a)=>i.fromPattern(e[a])(t)),n=t.split("/"),s=n.length,o=e.length,c=s>o?n.slice(o).map(i.ExcessSegment):[],l=a.concat(c);return[i.validate(e,l)].map(r.map(()=>i.transform(t,l,e))).shift()}const c=({tokenized:e,url:t})=>{const a=Object.entries(e).map(([e,a])=>[e,o(a.value,t)]),i=a.filter(([,e])=>"N"===e.case).map(([e,{value:t}])=>({[e]:t})).reduce((e,t)=>Object.assign(e,t),{}),s=a.filter(([,e])=>"Y"===e.case).sort(([,{value:e}],[,{value:t}])=>n.groupSpecificity(t)-n.groupSpecificity(e));return s.length?r.Y(s):r.N(i)},l=({routeType:e})=>t=>r.bifold(r.N,t=>0==t.length?r.N({}):r.Y(t.map(([t,{value:a}])=>e[t](i.toArgs(a)))))(t);function u(e,t){const a=Object.entries(t).map(([e,t])=>({[e]:s(t)})).reduce((e,t)=>Object.assign(e,t),{}),i=function({tokenized:e}){const t=[n.validateGroup(Object.entries(e))].flatMap(r.bifold(e=>e,()=>[])).shift(),a=Object.entries(e).filter(([,e])=>"N"===e.case).map(([e,t])=>[e,t.value]);return a.length?r.N(a.concat(t).concat(Object.entries(e).filter(([,e])=>"Y"===e.case).map(([e])=>[e,[]])).reduce((e,[t,a])=>(e[t]=e[t]||[],e[t]=e[t].concat(a),e),{})):r.Y(e)}({tokenized:a});if("N"===i.case)return i;{const t=function({typeName:e,tokenized:t}){return Object.entries(t).map(([t,a])=>{const i=a.value.reduce((e,t)=>n.fold({Path:()=>e,Part:t=>e.concat(t),Variadic:t=>e.concat(t)})(t),[]).sort();return{[t]:function(a){const n=Object.keys(a||{}).sort();return n.join("|")!==i.join("|")?r.N(new TypeError("Property mismatch for "+e+"."+t+".  Expected: {"+i.join(",")+"} but found: {"+n.join()+"}")):r.Y({type:e,case:t,value:a})}}}).reduce((e,t)=>Object.assign(e,t),{})}({typeName:e,tokenized:a}),i=function({safeRouteType:e}){return Object.entries(e).map(([e,t])=>({[e]:e=>r.fold({Y:e=>e,N(e){throw e}})(t(e))})).reduce((e,t)=>Object.assign(e,t),{})}({safeRouteType:t}),s=e=>t=>e[t.case](t.value),o=e=>{const t=c({tokenized:a,url:e});return l({routeType:i})(t)},u=(e,t)=>[t].map(o).flatMap(r.bifold(e,e=>e)).slice(0,1).concat(e({})).shift(),d=e=>a[e.case].value.map(n.fold({Part:t=>e.value[t],Path:e=>e,Variadic:t=>e.value[t]})).join("/");return r.Y({safe:t,of:i,fold:s,matches:o,matchOr:u,toURL:d})}}t.exports={tokenizePattern:s,tokenizeURL:o,PatternToken:n,URLToken:i,Valid:r,type$safe:u,type:(e,t)=>r.bifold(e=>{throw Object.values(e).flatMap(e=>e).map(e=>e.value).shift()},e=>e)(u(e,t))}},{}]},{},[1])(1)});
